services:
#  localstack:
#    image: localstack/localstack
#    container_name: localstack
#    ports:
#      - "4566:4566" # localstack AWS services port
#      - "4571:4571" # optional: old lambda port
#    environment:
#      - SERVICES=s3,dynamodb,lambda # the services we need from localstack
#      - DEBUG=1 # enable debug logs
#    volumes:
#      - /var/run/docker.sock:/var/run/docker.sock  # <-- This mounts the Docker socket
#    networks:
#      - notary-network

  server:
    build:
      context: ./server
      dockerfile: Dockerfile.dev
    container_name: server
    ports:
      # map the nestjs app running in SERVER_PORT number to host machine's
      # SERVER_PORT port as well. SERVER_PORT value is read from .env file by dc
      - "${SERVER_PORT}:${SERVER_PORT}"
#    depends_on:
#      - localstack
    volumes:
      - ./server:/usr/src/app # mount the local server folder to the container
      - /usr/src/app/node_modules # prevent overwriting node_mods inside the container
      - ./shared:/usr/src/app/shared  # Mount shared folder for the server
    environment:
      - PORT=${SERVER_PORT} # pass the value of SERVER_PORT to the nestjs server
      - AWS_ENDPOINT=${AWS_ENDPOINT}  # Use AWS_ENDPOINT from the .env file
    networks:
      - notary-network
  
  client:
    build:
      context: ./client
      dockerfile: Dockerfile.dev
    container_name: client
    ports:
      - "${CLIENT_PORT}:${CLIENT_PORT}"
    volumes:
      - ./client:/usr/src/app
      - /usr/src/app/node_modules # prevent overwriting node_mods inside the container
      - ./shared:/usr/src/app/shared  # Mount shared folder (same as above) for the client too
    environment:
      - PORT=${CLIENT_PORT} # pass the CLIENT_PORT value read from .env file to the client's Dockerfile
    networks:
      - notary-network

networks:
  notary-network:
    driver: bridge